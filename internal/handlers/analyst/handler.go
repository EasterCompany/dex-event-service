package analyst

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/EasterCompany/dex-event-service/internal/discord"
	"github.com/EasterCompany/dex-event-service/internal/ollama"
	"github.com/EasterCompany/dex-event-service/internal/web"
	"github.com/EasterCompany/dex-event-service/templates"
	"github.com/EasterCompany/dex-event-service/types"
	"github.com/EasterCompany/dex-event-service/utils"
	"github.com/google/uuid"
	"github.com/redis/go-redis/v9"
)

const (
	HandlerName     = "analyst-handler"
	LastAnalysisKey = "analyst:last_analysis_ts"
	ProcessID       = "system-analyst"
	DefaultModel    = "dex-analyst-guardian"
)

// getDexBinaryPath returns the absolute path to the dex binary in the user's home directory.
func getDexBinaryPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		// Fallback to a reasonable default or panic if critical,
		// but here we'll assume /home/owen/Dexter/bin/dex if home fails, which implies a bigger system issue.
		// A better fallback might be just "dex" and hope it's in PATH.
		return "dex"
	}
	return filepath.Join(home, "Dexter", "bin", "dex")
}

// AnalysisResult represents a single insight or blueprint generated by the model.
type AnalysisResult struct {
	Type               string   `json:"type"` // alert, notification, blueprint
	Title              string   `json:"title"`
	Priority           string   `json:"priority"`
	Category           string   `json:"category"`
	Body               string   `json:"body"`
	Summary            string   `json:"summary"`
	Content            string   `json:"content"`
	AffectedServices   []string `json:"affected_services"`
	ImplementationPath []string `json:"implementation_path"`
	RelatedEventIDs    []string `json:"related_event_ids"`
	AuditEventID       string   `json:"audit_event_id,omitempty"`
}

type AnalystHandler struct {
	RedisClient    *redis.Client
	OllamaClient   *ollama.Client
	DiscordClient  *discord.Client
	WebClient      *web.Client
	ChatManager    *utils.ChatContextManager
	lastAnalyzedTS int64
	stopChan       chan struct{}
	ctx            context.Context
	cancel         context.CancelFunc
}

func NewAnalystHandler(redis *redis.Client, ollama *ollama.Client, discord *discord.Client, web *web.Client, options interface{}) *AnalystHandler {
	ctx, cancel := context.WithCancel(context.Background())
	return &AnalystHandler{
		RedisClient:   redis,
		OllamaClient:  ollama,
		DiscordClient: discord,
		WebClient:     web,
		ChatManager:   utils.NewChatContextManager(redis),
		ctx:           ctx,
		cancel:        cancel,
	}
}

func (h *AnalystHandler) Init(ctx context.Context) error {
	h.stopChan = make(chan struct{})

	// Load last analyzed timestamp
	ts, _ := h.RedisClient.Get(h.ctx, LastAnalysisKey).Int64()
	h.lastAnalyzedTS = ts
	if h.lastAnalyzedTS == 0 {
		h.lastAnalyzedTS = time.Now().Add(-24 * time.Hour).Unix()
	}

	go h.runWorker()
	log.Printf("[%s] Background worker started.", HandlerName)
	return nil
}

func (h *AnalystHandler) Close() error {
	if h.cancel != nil {
		h.cancel() // Cancel ongoing Ollama/HTTP calls
	}
	if h.stopChan != nil {
		close(h.stopChan)
	}
	// Clear process entry from dashboard
	utils.ClearProcess(context.Background(), h.RedisClient, h.DiscordClient, ProcessID)
	return nil
}

func (h *AnalystHandler) HandleEvent(ctx context.Context, event *types.Event) error {
	return nil
}

func (h *AnalystHandler) runWorker() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-h.stopChan:
			return
		case <-ticker.C:
			h.checkAndAnalyze()
		}
	}
}

func (h *AnalystHandler) checkAndAnalyze() {
	lastCognitiveEvent, _ := h.RedisClient.Get(h.ctx, "system:last_cognitive_event").Int64()
	lastAnalysisDiff := time.Since(time.Unix(h.lastAnalyzedTS, 0))

	isIdle := time.Since(time.Unix(lastCognitiveEvent, 0)) >= 30*time.Second
	forceRun := lastAnalysisDiff > 6*time.Hour

	if !isIdle && !forceRun {
		return
	}

	if lastAnalysisDiff < 1*time.Hour {
		return
	}

	// Ensure we clear the process status and active tier when we finish (or error out)
	defer h.RedisClient.Del(h.ctx, "analyst:active_tier")
	defer utils.ClearProcess(h.ctx, h.RedisClient, h.DiscordClient, ProcessID)

	// log.Printf("[%s] Analysis trigger: Idle=%v, Force=%v. Starting cycle...", HandlerName, isIdle, forceRun)

	// TRIGGER: Run system tests before analysis to provide fresh data
	h.runSystemTests(h.ctx)

	untilTS := time.Now().Unix()
	sinceTS := h.lastAnalyzedTS

	results, err := h.PerformAnalysis(h.ctx, sinceTS, untilTS)
	if err != nil {
		if err == context.Canceled {
			log.Printf("[%s] Analysis cycle cancelled during shutdown.", HandlerName)
			return
		}
		log.Printf("[%s] Analysis failed: %v", HandlerName, err)
		return
	}

	for _, res := range results {
		if _, err := h.emitResult(h.ctx, res); err != nil {
			log.Printf("[%s] Failed to emit result for %s: %v", HandlerName, res.Title, err)
		}
	}

	// ONLY update the timestamp if we finished successfully and weren't cancelled
	h.lastAnalyzedTS = untilTS
	h.RedisClient.Set(h.ctx, LastAnalysisKey, h.lastAnalyzedTS, utils.DefaultTTL)
	// log.Printf("[%s] Analysis coverage updated to %s.", HandlerName, time.Unix(h.lastAnalyzedTS, 0).Format(time.RFC3339))
}

func (h *AnalystHandler) runSystemTests(ctx context.Context) {
	// log.Printf("[%s] Running pre-analysis system tests...", HandlerName)
	h.RedisClient.Set(ctx, "analyst:active_tier", "tests", utils.DefaultTTL)
	utils.ReportProcess(ctx, h.RedisClient, h.DiscordClient, ProcessID, "Running System Tests")

	// Create a context with timeout for tests (15 minutes)
	testCtx, cancel := context.WithTimeout(ctx, 15*time.Minute)
	defer cancel()

	// Execute 'dex test' command
	dexPath := getDexBinaryPath()
	cmd := exec.CommandContext(testCtx, dexPath, "test")
	output, err := cmd.CombinedOutput()
	if err != nil {
		if testCtx.Err() == context.DeadlineExceeded {
			log.Printf("[%s] System tests timed out after 15 minutes.", HandlerName)
		} else {
			log.Printf("[%s] System tests failed: %v (Output: %s)", HandlerName, err, string(output))
		}
	} else {
		log.Printf("[%s] System tests completed successfully.", HandlerName)
	}
}

func (h *AnalystHandler) PerformAnalysis(ctx context.Context, sinceTS, untilTS int64) ([]AnalysisResult, error) {
	events, err := h.fetchEventsForAnalysis(ctx, sinceTS, untilTS)
	// ... (skipping to fetchTestResults modification location, wait, I need to find fetchTestResults definition)
	// I will just modify runSystemTests first as it is visible in the context I have.
	// I will search for fetchTestResults definition to modify it separately.
	if err != nil {
		return nil, err
	}

	status, _ := h.fetchSystemStatus(ctx)
	systemInfo, _ := h.fetchSystemHardware(ctx)
	logs, _ := h.fetchRecentLogs(ctx)
	tests, _ := h.fetchTestResults(ctx)
	history, _ := h.fetchRecentNotifications(ctx, 20)

	var allResults []AnalysisResult

	// --- Tier 1: Guardian ---
	h.RedisClient.Set(ctx, "analyst:active_tier", "guardian", utils.DefaultTTL)
	utils.ReportProcess(ctx, h.RedisClient, h.DiscordClient, ProcessID, "Tier 1: Guardian Analysis")

	gResults, err := h.runTierAnalysis(ctx, "guardian", events, history, status, systemInfo, logs, tests)
	if err == nil {
		allResults = append(allResults, gResults...)
	} else {
		log.Printf("[%s] Guardian analysis failed: %v", HandlerName, err)
	}

	// --- Tier 2: Architect ---
	lastArchitectRun, _ := h.RedisClient.Get(ctx, "analyst:last_run:architect").Result()
	lastArchTS, _ := strconv.ParseInt(lastArchitectRun, 10, 64)

	if time.Since(time.Unix(lastArchTS, 0)) >= 2*time.Hour {
		h.RedisClient.Set(ctx, "analyst:active_tier", "architect", utils.DefaultTTL)
		utils.ReportProcess(ctx, h.RedisClient, h.DiscordClient, ProcessID, "Tier 2: Architect Analysis")

		aResults, err := h.runTierAnalysis(ctx, "architect", events, history, status, systemInfo, logs, tests)
		if err == nil {
			allResults = append(allResults, aResults...)
			h.RedisClient.Set(ctx, "analyst:last_run:architect", time.Now().Unix(), utils.DefaultTTL)
		} else {
			log.Printf("[%s] Architect analysis failed: %v", HandlerName, err)
		}
	}

	// --- Tier 3: Strategist ---
	lastStrategistRun, _ := h.RedisClient.Get(ctx, "analyst:last_run:strategist").Result()
	lastStratTS, _ := strconv.ParseInt(lastStrategistRun, 10, 64)

	if time.Since(time.Unix(lastStratTS, 0)) >= 3*time.Hour {
		h.RedisClient.Set(ctx, "analyst:active_tier", "strategist", utils.DefaultTTL)
		utils.ReportProcess(ctx, h.RedisClient, h.DiscordClient, ProcessID, "Tier 3: Strategist Analysis")

		// Retrieve roadmap context
		roadmapItem := h.fetchOldestPublishedRoadmapItem(ctx)
		var roadmapContent string
		if roadmapItem != nil {
			roadmapContent = fmt.Sprintf("### PRIMARY CREATOR OBJECTIVE (PRIORITY #1):\n%s", roadmapItem.Content)
		}

		// Run analysis with roadmap injected into 'systemInfo' or 'history' effectively
		// We append roadmap content to logs/tests input for Strategist
		strategistInput := fmt.Sprintf("%s\n\n%s", roadmapContent, tests)

		sResults, err := h.runTierAnalysis(ctx, "strategist", events, history, status, systemInfo, logs, strategistInput)
		if err == nil {
			if roadmapItem != nil && len(sResults) > 0 {
				roadmapItem.State = types.RoadmapStateConsumed
				roadmapItem.ConsumedAt = time.Now().Unix()
				h.updateRoadmapItem(ctx, roadmapItem)
			}
			allResults = append(allResults, sResults...)
			h.RedisClient.Set(ctx, "analyst:last_run:strategist", time.Now().Unix(), utils.DefaultTTL)
		} else {
			log.Printf("[%s] Strategist analysis failed: %v", HandlerName, err)
		}
	}

	return allResults, nil
}

func (h *AnalystHandler) parseAnalysisResults(response string) []AnalysisResult {
	if strings.Contains(response, "No significant insights found.") {
		return nil
	}

	var results []AnalysisResult
	// Split by '---' only when it's on its own line to avoid splitting on markdown tables
	re := regexp.MustCompile(`(?m)^\s*---\s*$`)
	sections := re.Split(response, -1)
	for _, section := range sections {
		res := h.parseSingleMarkdownReport(section)
		if res.Title != "" {
			results = append(results, res)
		}
	}
	return results
}

func (h *AnalystHandler) parseSingleMarkdownReport(input string) AnalysisResult {
	var res AnalysisResult
	lines := strings.Split(input, "\n")

	var currentSection string
	var contentLines []string
	var pathLines []string
	var summaryLines []string
	foundHeader := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		if !foundHeader {
			if strings.HasPrefix(trimmed, "# ") {
				res.Title = strings.TrimPrefix(trimmed, "# ")
				foundHeader = true
			}
			continue
		}

		if strings.HasPrefix(trimmed, "**Type**:") {
			res.Type = strings.ToLower(strings.TrimSpace(strings.TrimPrefix(trimmed, "**Type**:")))
			continue
		}
		if strings.HasPrefix(trimmed, "**Priority**:") {
			res.Priority = strings.ToLower(strings.TrimSpace(strings.TrimPrefix(trimmed, "**Priority**:")))
			continue
		}
		if strings.HasPrefix(trimmed, "**Category**:") {
			res.Category = strings.ToLower(strings.TrimSpace(strings.TrimPrefix(trimmed, "**Category**:")))
			continue
		}
		if strings.HasPrefix(trimmed, "**Affected**:") {
			affectedRaw := strings.TrimSpace(strings.TrimPrefix(trimmed, "**Affected**:"))
			parts := strings.Split(affectedRaw, ",")
			for _, p := range parts {
				p = strings.TrimSpace(p)
				if p != "" {
					res.AffectedServices = append(res.AffectedServices, p)
				}
			}
			continue
		}
		if strings.HasPrefix(trimmed, "**Related IDs**:") {
			idsRaw := strings.TrimSpace(strings.TrimPrefix(trimmed, "**Related IDs**:"))
			parts := strings.Split(idsRaw, ",")
			for _, p := range parts {
				p = strings.TrimSpace(p)
				if p != "" {
					res.RelatedEventIDs = append(res.RelatedEventIDs, p)
				}
			}
			continue
		}

		if strings.HasPrefix(trimmed, "## Summary") || strings.HasPrefix(trimmed, "### Summary") || strings.HasPrefix(trimmed, "**Summary**") {
			currentSection = "summary"
			continue
		}
		if strings.HasPrefix(trimmed, "## Content") || strings.HasPrefix(trimmed, "### Content") || strings.HasPrefix(trimmed, "**Content**") ||
			strings.HasPrefix(trimmed, "## Insight") || strings.HasPrefix(trimmed, "### Insight") || strings.HasPrefix(trimmed, "**Insight**") ||
			strings.HasPrefix(trimmed, "## Analysis") || strings.HasPrefix(trimmed, "### Analysis") ||
			strings.HasPrefix(trimmed, "## Observations") || strings.HasPrefix(trimmed, "### Observations") {
			currentSection = "content"
			continue
		}
		if strings.HasPrefix(trimmed, "## Implementation Path") || strings.HasPrefix(trimmed, "### Implementation Path") || strings.HasPrefix(trimmed, "**Implementation Path**") {
			currentSection = "path"
			continue
		}

		switch currentSection {
		case "summary":
			summaryLines = append(summaryLines, line)
		case "content":
			contentLines = append(contentLines, line)
		case "path":
			if strings.HasPrefix(trimmed, "1.") || strings.HasPrefix(trimmed, "2.") ||
				strings.HasPrefix(trimmed, "3.") || strings.HasPrefix(trimmed, "4.") ||
				strings.HasPrefix(trimmed, "5.") || strings.HasPrefix(trimmed, "6.") ||
				strings.HasPrefix(trimmed, "7.") || strings.HasPrefix(trimmed, "8.") ||
				strings.HasPrefix(trimmed, "9.") || strings.HasPrefix(trimmed, "-") ||
				strings.HasPrefix(trimmed, "*") {

				var cleaned string
				if idx := strings.Index(trimmed, "."); idx != -1 && idx < 3 {
					cleaned = strings.TrimSpace(trimmed[idx+1:])
				} else {
					cleaned = strings.TrimSpace(strings.TrimPrefix(strings.TrimPrefix(trimmed, "-"), "*"))
				}
				if cleaned != "" {
					pathLines = append(pathLines, cleaned)
				}
			}
		}
	}

	res.Summary = strings.TrimSpace(strings.Join(summaryLines, "\n"))
	res.Content = strings.TrimSpace(strings.Join(contentLines, "\n"))
	res.ImplementationPath = pathLines

	if res.Type != "blueprint" {
		res.Body = res.Content
		if res.Body == "" {
			res.Body = res.Summary
		}
	} else {
		res.Body = res.Summary
	}

	return res
}

func (h *AnalystHandler) fetchLastAudit(ctx context.Context, tier string) (string, string, error) {
	ids, err := h.RedisClient.ZRevRange(ctx, "events:service:"+HandlerName, 0, 50).Result()
	if err != nil {
		return "", "", err
	}

	for _, id := range ids {
		val, err := h.RedisClient.Get(ctx, "event:"+id).Result()
		if err != nil {
			continue
		}

		var evt types.Event
		if json.Unmarshal([]byte(val), &evt) != nil {
			continue
		}

		var payload map[string]interface{}
		if json.Unmarshal(evt.Event, &payload) != nil {
			continue
		}

		if payload["type"] == string(types.EventTypeSystemAnalysisAudit) && payload["tier"] == tier {
			input, _ := payload["raw_input"].(string)
			output, _ := payload["raw_output"].(string)
			return input, output, nil
		}
	}
	return "", "", fmt.Errorf("no recent audit found")
}

func (h *AnalystHandler) emitAttentionExpired(ctx context.Context, tier string, lastActive int64) {
	eventID := uuid.New().String()
	timestamp := time.Now().Unix()

	// Track Waste Time
	waste := timestamp - lastActive
	h.RedisClient.IncrBy(ctx, "system:metrics:cognitive_waste_seconds", waste)

	input, output, _ := h.fetchLastAudit(ctx, tier)

	payload := map[string]interface{}{
		"type":        "system.attention.expired",
		"tier":        tier,
		"last_active": lastActive,
		"expired_at":  time.Unix(lastActive, 0).Add(utils.DefaultAttentionSpan).Unix(),
		"timestamp":   timestamp,
		"last_input":  input,
		"last_output": output,
	}

	eventJSON, _ := json.Marshal(payload)
	event := types.Event{
		ID:        eventID,
		Service:   HandlerName,
		Event:     eventJSON,
		Timestamp: timestamp,
	}
	fullEventJSON, _ := json.Marshal(event)
	pipe := h.RedisClient.Pipeline()
	pipe.Set(ctx, "event:"+eventID, fullEventJSON, utils.DefaultTTL)
	pipe.ZAdd(ctx, "events:timeline", redis.Z{Score: float64(timestamp), Member: eventID})
	pipe.ZAdd(ctx, "events:service:"+HandlerName, redis.Z{Score: float64(timestamp), Member: eventID})
	_, _ = pipe.Exec(ctx)
}

func (h *AnalystHandler) emitAudit(ctx context.Context, tier, model, input, output string, duration int64) (string, error) {
	eventID := uuid.New().String()
	timestamp := time.Now().Unix()

	// Track Active Time
	h.RedisClient.IncrBy(ctx, "system:metrics:cognitive_active_seconds", duration)

	payload := map[string]interface{}{
		"type":       string(types.EventTypeSystemAnalysisAudit),
		"tier":       tier,
		"model":      model,
		"raw_input":  input,
		"raw_output": output,
		"duration":   duration,
		"timestamp":  timestamp,
	}

	eventJSON, _ := json.Marshal(payload)
	event := types.Event{
		ID:        eventID,
		Service:   HandlerName,
		Event:     eventJSON,
		Timestamp: timestamp,
	}
	fullEventJSON, _ := json.Marshal(event)
	pipe := h.RedisClient.Pipeline()
	pipe.Set(ctx, "event:"+eventID, fullEventJSON, utils.DefaultTTL)
	pipe.ZAdd(ctx, "events:timeline", redis.Z{Score: float64(timestamp), Member: eventID})
	pipe.ZAdd(ctx, "events:service:"+HandlerName, redis.Z{Score: float64(timestamp), Member: eventID})
	_, err := pipe.Exec(ctx)
	return eventID, err
}

func (h *AnalystHandler) fetchEventsForAnalysis(ctx context.Context, sinceTS, untilTS int64) ([]types.Event, error) {
	// Limit to most recent 50 events to keep context concise
	eventIDs, err := h.RedisClient.ZRevRangeByScore(ctx, "events:timeline", &redis.ZRangeBy{
		Min: fmt.Sprintf("%d", sinceTS+1),
		Max: fmt.Sprintf("%d", untilTS),
	}).Result()

	if err != nil || len(eventIDs) == 0 {
		return nil, err
	}

	// Cap at 50 most recent events
	if len(eventIDs) > 50 {
		eventIDs = eventIDs[:50]
	}

	ignoredEventTypes := []string{
		string(types.EventTypeCLIStatus),
		string(types.EventTypeMessagingBotStatusUpdate),
		string(types.EventTypeMessagingUserSpeakingStarted),
		string(types.EventTypeMessagingUserSpeakingStopped),
		string(types.EventTypeSystemAnalysisAudit),
		"system.roadmap.updated",
		"system.process.registered",
		"system.process.unregistered",
	}

	events := make([]types.Event, 0, len(eventIDs))
	pipe := h.RedisClient.Pipeline()
	cmds := make([]*redis.StringCmd, len(eventIDs))
	for i, eventID := range eventIDs {
		cmds[i] = pipe.Get(ctx, "event:"+eventID)
	}
	_, _ = pipe.Exec(ctx)

	for _, cmd := range cmds {
		eventJSON, err := cmd.Result()
		if err != nil {
			continue
		}
		var event types.Event
		_ = json.Unmarshal([]byte(eventJSON), &event)

		// Filter out dex-discord-service events to reduce context noise
		if event.Service == "dex-discord-service" {
			continue
		}

		var eventData map[string]interface{}
		if err := json.Unmarshal(event.Event, &eventData); err == nil {
			eventType, _ := eventData["type"].(string)
			if eventType == string(types.EventTypeSystemNotificationGenerated) || eventType == string(types.EventTypeSystemBlueprintGenerated) {
				continue
			}
			isIgnored := false
			for _, ignored := range ignoredEventTypes {
				if eventType == ignored {
					isIgnored = true
					break
				}
			}
			if isIgnored {
				continue
			}
		}
		events = append(events, event)
	}
	return events, nil
}

func (h *AnalystHandler) fetchSystemStatus(ctx context.Context) (string, error) {
	// Run 'dex status' to get a pretty-printed table of system status
	dexPath := getDexBinaryPath()
	cmd := exec.CommandContext(ctx, dexPath, "status")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to run dex status: %v (output: %s)", err, string(output))
	}
	return utils.StripANSI(string(output)), nil
}

func (h *AnalystHandler) fetchSystemHardware(ctx context.Context) (string, error) {
	// Run 'dex system' to get hardware info
	dexPath := getDexBinaryPath()
	cmd := exec.CommandContext(ctx, dexPath, "system")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to run dex system: %v (output: %s)", err, string(output))
	}
	return utils.StripANSI(string(output)), nil
}

func (h *AnalystHandler) fetchRecentLogs(ctx context.Context) (string, error) {
	dexPath := getDexBinaryPath()
	// Run 'dex logs' to get recent logs from all services (defaults to tail -n 10 per service)
	cmd := exec.CommandContext(ctx, dexPath, "logs")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to run dex logs: %v (output: %s)", err, string(output))
	}
	return utils.StripANSI(string(output)), nil
}

func (h *AnalystHandler) fetchTestResults(ctx context.Context) (string, error) {
	// Query last 250 events to find system.test.completed (increased from 100)
	eventIDs, err := h.RedisClient.ZRevRange(ctx, "events:timeline", 0, 250).Result()
	if err != nil {
		return "", err
	}
	// log.Printf("[%s] Scanned %d events for test results.", HandlerName, len(eventIDs))

	var testSummaries []string
	seenServices := make(map[string]bool)

	for _, id := range eventIDs {
		data, _ := h.RedisClient.Get(ctx, "event:"+id).Result()
		var e types.Event
		if err := json.Unmarshal([]byte(data), &e); err == nil {
			var ed map[string]interface{}
			_ = json.Unmarshal(e.Event, &ed)

			if ed["type"] == string(types.EventTypeSystemTestCompleted) {
				svc, _ := ed["service_name"].(string)
				if svc != "" && !seenServices[svc] {
					// Format a nice summary line
					format, _ := ed["format"].(map[string]interface{})
					lint, _ := ed["lint"].(map[string]interface{})
					test, _ := ed["test"].(map[string]interface{})

					summary := fmt.Sprintf("[%s] Format: %s, Lint: %s, Test: %s (%s)",
						svc, format["status"], lint["status"], test["details"], ed["duration"])
					testSummaries = append(testSummaries, summary)
					seenServices[svc] = true
				}
			}
		}
	}

	if len(testSummaries) == 0 {
		log.Printf("[%s] WARNING: No system.test.completed events found in the last %d events.", HandlerName, len(eventIDs))
		return "No recent test results available.", nil
	}

	return strings.Join(testSummaries, "\n"), nil
}
func (h *AnalystHandler) fetchRecentNotifications(ctx context.Context, limit int) (string, error) {
	eventIDs, err := h.RedisClient.ZRevRange(ctx, "events:service:"+HandlerName, 0, int64(limit-1)).Result()
	if err != nil {
		return "", err
	}
	var history []string
	for _, id := range eventIDs {
		data, _ := h.RedisClient.Get(ctx, "event:"+id).Result()
		var e types.Event
		if err := json.Unmarshal([]byte(data), &e); err == nil {
			var ed map[string]interface{}
			_ = json.Unmarshal(e.Event, &ed)
			title, _ := ed["title"].(string)
			if title != "" {
				history = append(history, fmt.Sprintf("- %s", title))
			}
		}
	}
	return strings.Join(history, "\n"), nil
}

func (h *AnalystHandler) runTierAnalysis(ctx context.Context, tier string, events []types.Event, history, status, systemInfo, logs, tests string) ([]AnalysisResult, error) {
	sessionID := tier // e.g., "guardian"
	var model, systemPrompt string

	switch tier {
	case "guardian":
		model = "dex-analyst-guardian"
		systemPrompt = utils.GetAnalystGuardianPrompt()
	case "architect":
		model = "dex-analyst-architect"
		systemPrompt = utils.GetAnalystArchitectPrompt()
	case "strategist":
		model = "dex-analyst-strategist"
		systemPrompt = utils.GetAnalystStrategistPrompt()
	default:
		return nil, fmt.Errorf("unknown tier: %s", tier)
	}

	// Load Chat History
	chatHistory, err := h.ChatManager.LoadHistory(ctx, sessionID)
	if err != nil {
		log.Printf("[%s] Failed to load chat history for %s: %v", HandlerName, tier, err)
		chatHistory = []ollama.Message{}
	}

	// Ensure System Prompt is at the start if history is empty or corrupted
	if len(chatHistory) == 0 || chatHistory[0].Role != "system" {
		// If the first message isn't system (or history empty), reset with correct system prompt
		chatHistory = append([]ollama.Message{{Role: "system", Content: systemPrompt}}, chatHistory...)
	} else {
		// Enforce current system prompt logic if it changed (optional, but good practice)
		chatHistory[0].Content = systemPrompt
	}

	// Check for "Attention Expiration"
	lastActiveKey := "analyst:memory:last_active:" + sessionID
	lastActiveTS, _ := h.RedisClient.Get(ctx, lastActiveKey).Int64()

	// If history is effectively empty (just system prompt) and we had a previous active session
	if len(chatHistory) <= 1 && lastActiveTS > 0 {
		sinceActive := time.Since(time.Unix(lastActiveTS, 0))
		// If last active was > AttentionSpan (expired) but < 24 hours (recent enough to care)
		if sinceActive > utils.DefaultAttentionSpan && sinceActive < 24*time.Hour {
			h.emitAttentionExpired(ctx, tier, lastActiveTS)
		}
	}

	// Update Last Active Timestamp (Persistent)
	h.RedisClient.Set(ctx, lastActiveKey, time.Now().Unix(), utils.DefaultTTL)

	// Construct the Input (User Message)
	var eventLines []string
	for _, e := range events {
		var ed map[string]interface{}
		_ = json.Unmarshal(e.Event, &ed)
		eventType, _ := ed["type"].(string)
		summary := templates.FormatEventAsText(eventType, ed, e.Service, e.Timestamp, 0, "UTC", "en")
		eventLines = append(eventLines, summary)
	}

	// Dynamic Context Injection
	inputContext := fmt.Sprintf("### CURRENT SYSTEM STATUS\n%s\n\n### TEST RESULTS\n%s\n\n### HARDWARE\n%s\n\n### RECENT LOGS\n%s\n\n### NEW EVENTS\n%s\n\n### REPORTED ISSUES HISTORY\n%s",
		status, tests, systemInfo, logs, strings.Join(eventLines, "\n"), history)

	newUserMsg := ollama.Message{
		Role:    "user",
		Content: inputContext,
	}

	// Work with a local copy of history for the retry loop
	currentTurnHistory := append(chatHistory, newUserMsg)

	// Retry Loop for Self-Correction
	startTime := time.Now().Unix()
	maxRetries := 3
	for i := 0; i < maxRetries; i++ {
		tCtx, cancel := context.WithTimeout(ctx, 5*time.Minute)
		respMsg, err := h.OllamaClient.Chat(tCtx, model, currentTurnHistory)
		cancel()

		if err != nil {
			return nil, fmt.Errorf("chat generation failed: %v", err)
		}

		// Validate Output
		results := h.parseAnalysisResults(respMsg.Content)
		isValid := len(results) > 0 || strings.Contains(respMsg.Content, "No significant insights found")

		if isValid {
			// Success! Emit audit
			duration := time.Now().Unix() - startTime
			auditID, _ := h.emitAudit(ctx, tier, model, inputContext, respMsg.Content, duration)

			for i := range results {
				results[i].AuditEventID = auditID
			}

			// Persist the *clean* interaction to long-term memory
			// We append the initial User Request and the Final Successful Response
			_ = h.ChatManager.AppendMessage(ctx, sessionID, newUserMsg)
			_ = h.ChatManager.AppendMessage(ctx, sessionID, respMsg)

			return results, nil
		}

		// Failure: Malformed Output
		log.Printf("[%s] Malformed output from %s (Attempt %d/%d). Triggering self-correction...", HandlerName, tier, i+1, maxRetries)

		// Add the bad response and the correction instruction to the *temporary* loop history
		currentTurnHistory = append(currentTurnHistory, respMsg)

		correctionMsg := ollama.Message{
			Role: "user",
			Content: "SYSTEM ERROR: Your response did not follow the strict 'Dexter Report' format. \n" +
				"You must output ONLY Markdown reports separated by '---' or 'No significant insights found.'.\n" +
				"Do not include prose. Fix your output immediately.",
		}
		currentTurnHistory = append(currentTurnHistory, correctionMsg)
	}

	return nil, fmt.Errorf("max retries reached for %s", tier)
}

func (h *AnalystHandler) emitResult(ctx context.Context, res AnalysisResult) (string, error) {
	eventID := uuid.New().String()
	timestamp := time.Now().Unix()

	var eventType string
	payload := map[string]interface{}{
		"title":             res.Title,
		"priority":          res.Priority,
		"category":          res.Category,
		"body":              res.Body,
		"related_event_ids": res.RelatedEventIDs,
		"read":              false,
	}

	if res.AuditEventID != "" {
		payload["audit_event_id"] = res.AuditEventID
	}

	switch res.Type {
	case "alert":
		eventType = string(types.EventTypeSystemNotificationGenerated)
		payload["alert"] = true
	case "blueprint":
		eventType = string(types.EventTypeSystemBlueprintGenerated)
		payload["summary"] = res.Summary
		payload["content"] = res.Content
		payload["affected_services"] = res.AffectedServices
		payload["implementation_path"] = res.ImplementationPath
	default:
		eventType = string(types.EventTypeSystemNotificationGenerated)
	}

	payload["type"] = eventType
	eventJSON, _ := json.Marshal(payload)
	event := types.Event{
		ID:        eventID,
		Service:   HandlerName,
		Event:     eventJSON,
		Timestamp: timestamp,
	}
	fullEventJSON, _ := json.Marshal(event)
	pipe := h.RedisClient.Pipeline()
	pipe.Set(ctx, "event:"+eventID, fullEventJSON, utils.DefaultTTL)
	pipe.ZAdd(ctx, "events:timeline", redis.Z{Score: float64(timestamp), Member: eventID})
	pipe.ZAdd(ctx, "events:service:"+HandlerName, redis.Z{Score: float64(timestamp), Member: eventID})
	_, err := pipe.Exec(ctx)
	log.Printf("[%s] Emitted %s: \"%s\"", HandlerName, res.Type, res.Title)
	return eventID, err
}

func (h *AnalystHandler) fetchOldestPublishedRoadmapItem(ctx context.Context) *types.RoadmapItem {
	keys, err := h.RedisClient.Keys(ctx, "roadmap:*").Result()
	if err != nil || len(keys) == 0 {
		return nil
	}

	var items []types.RoadmapItem
	for _, key := range keys {
		data, err := h.RedisClient.Get(ctx, key).Result()
		if err != nil {
			continue
		}
		var item types.RoadmapItem
		if err := json.Unmarshal([]byte(data), &item); err == nil && item.State == types.RoadmapStatePublished {
			items = append(items, item)
		}
	}

	if len(items) == 0 {
		return nil
	}

	sort.Slice(items, func(i, j int) bool {
		return items[i].CreatedAt < items[j].CreatedAt
	})

	return &items[0]
}

func (h *AnalystHandler) updateRoadmapItem(ctx context.Context, item *types.RoadmapItem) {
	data, _ := json.Marshal(item)
	h.RedisClient.Set(ctx, "roadmap:"+item.ID, data, utils.DefaultTTL)
}
