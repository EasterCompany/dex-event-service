package analyst

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/EasterCompany/dex-event-service/internal/discord"
	"github.com/EasterCompany/dex-event-service/internal/ollama"
	"github.com/EasterCompany/dex-event-service/internal/web"
	"github.com/EasterCompany/dex-event-service/templates"
	"github.com/EasterCompany/dex-event-service/types"
	"github.com/EasterCompany/dex-event-service/utils"
	"github.com/google/uuid"
	"github.com/redis/go-redis/v9"
)

const (
	HandlerName     = "analyst-handler"
	LastAnalysisKey = "analyst:last_analysis_ts"
	ProcessID       = "system-analyst"
	DefaultModel    = "dex-analyst-guardian"
)

// AnalysisResult represents a single insight or blueprint generated by the model.
type AnalysisResult struct {
	Type               string   `json:"type"` // alert, notification, blueprint
	Title              string   `json:"title"`
	Priority           string   `json:"priority"`
	Category           string   `json:"category"`
	Body               string   `json:"body"`
	Summary            string   `json:"summary"`
	Content            string   `json:"content"`
	AffectedServices   []string `json:"affected_services"`
	ImplementationPath []string `json:"implementation_path"`
	RelatedEventIDs    []string `json:"related_event_ids"`
}

type AnalystHandler struct {
	RedisClient    *redis.Client
	OllamaClient   *ollama.Client
	DiscordClient  *discord.Client
	WebClient      *web.Client
	lastAnalyzedTS int64
	stopChan       chan struct{}
}

func NewAnalystHandler(redis *redis.Client, ollama *ollama.Client, discord *discord.Client, web *web.Client, options interface{}) *AnalystHandler {
	return &AnalystHandler{
		RedisClient:   redis,
		OllamaClient:  ollama,
		DiscordClient: discord,
		WebClient:     web,
	}
}

func (h *AnalystHandler) Init(ctx context.Context) error {
	h.stopChan = make(chan struct{})

	// Load last analyzed timestamp
	ts, _ := h.RedisClient.Get(context.Background(), LastAnalysisKey).Int64()
	h.lastAnalyzedTS = ts
	if h.lastAnalyzedTS == 0 {
		h.lastAnalyzedTS = time.Now().Add(-24 * time.Hour).Unix()
	}

	go h.runWorker()
	log.Printf("[%s] Background worker started.", HandlerName)
	return nil
}

func (h *AnalystHandler) Close() error {
	if h.stopChan != nil {
		close(h.stopChan)
	}
	// Clear process entry from dashboard
	utils.ClearProcess(context.Background(), h.RedisClient, h.DiscordClient, ProcessID)
	return nil
}

func (h *AnalystHandler) HandleEvent(ctx context.Context, event *types.Event) error {
	return nil
}

func (h *AnalystHandler) runWorker() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-h.stopChan:
			return
		case <-ticker.C:
			h.checkAndAnalyze()
		}
	}
}

func (h *AnalystHandler) checkAndAnalyze() {
	ctx := context.Background()

	lastCognitiveEvent, _ := h.RedisClient.Get(ctx, "system:last_cognitive_event").Int64()
	lastAnalysisDiff := time.Since(time.Unix(h.lastAnalyzedTS, 0))

	// Logic: System is idle if no high-priority cognitive events in last 60s
	isIdle := time.Since(time.Unix(lastCognitiveEvent, 0)) >= 60*time.Second

	// If it's been more than 2 hours, we FORCE an analysis even if not "idle"
	// (to prevent permanent blockage by constant chatter)
	forceRun := lastAnalysisDiff > 2*time.Hour

	if !isIdle && !forceRun {
		return
	}

	// Minimum interval of 5 minutes between runs
	if lastAnalysisDiff < 5*time.Minute {
		return
	}

	log.Printf("[%s] Analysis trigger: Idle=%v, Force=%v. Starting cycle...", HandlerName, isIdle, forceRun)
	untilTS := time.Now().Unix()
	sinceTS := h.lastAnalyzedTS

	results, err := h.PerformAnalysis(ctx, sinceTS, untilTS)
	if err != nil {
		log.Printf("[%s] Analysis failed: %v", HandlerName, err)
		return
	}

	for _, res := range results {
		h.emitResult(ctx, res)
	}

	h.lastAnalyzedTS = untilTS
	h.RedisClient.Set(ctx, LastAnalysisKey, h.lastAnalyzedTS, 0)
	log.Printf("[%s] Analysis coverage updated to %s.", HandlerName, time.Unix(h.lastAnalyzedTS, 0).Format(time.RFC3339))
}

func (h *AnalystHandler) PerformAnalysis(ctx context.Context, sinceTS, untilTS int64) ([]AnalysisResult, error) {
	events, err := h.fetchEventsForAnalysis(ctx, sinceTS, untilTS)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch events: %w", err)
	}

	status, _ := h.fetchSystemStatus()
	logs, _ := h.fetchRecentLogs()
	tests, _ := h.fetchTestResults()
	history, _ := h.fetchRecentNotifications(ctx, 20)

	var allResults []AnalysisResult

	// --- Tier 1: Guardian ---
	utils.ReportProcess(ctx, h.RedisClient, h.DiscordClient, "system-analyst", "Tier 1: Guardian Analysis")
	guardianPrompt := h.buildAnalysisPrompt(events, history, status, logs, tests, "guardian")
	log.Printf("[%s] Executing Tier 1 (Guardian) Analysis...", HandlerName)

	guardianModel := "dex-analyst-guardian"
	ollamaGResponse, err := h.OllamaClient.Generate(guardianModel, guardianPrompt, nil)
	if err == nil {
		h.emitAudit(ctx, "guardian", guardianModel, guardianPrompt, ollamaGResponse)
		gResults := h.parseAnalysisResults(ollamaGResponse)
		allResults = append(allResults, gResults...)
	}

	// --- Tier 2: Architect ---
	lastArchitectRun, _ := h.RedisClient.Get(ctx, "analyst:last_run:architect").Result()
	lastArchTS, _ := strconv.ParseInt(lastArchitectRun, 10, 64)

	if time.Since(time.Unix(lastArchTS, 0)) >= 15*time.Minute {
		utils.ReportProcess(ctx, h.RedisClient, h.DiscordClient, "system-analyst", "Tier 2: Architect Analysis")
		architectPrompt := h.buildAnalysisPrompt(events, history, status, logs, tests, "architect")
		log.Printf("[%s] Executing Tier 2 (Architect) Analysis...", HandlerName)

		architectModel := "dex-analyst-architect"
		ollamaAResponse, err := h.OllamaClient.Generate(architectModel, architectPrompt, nil)
		if err == nil {
			h.emitAudit(ctx, "architect", architectModel, architectPrompt, ollamaAResponse)
			aResults := h.parseAnalysisResults(ollamaAResponse)
			allResults = append(allResults, aResults...)
			h.RedisClient.Set(ctx, "analyst:last_run:architect", time.Now().Unix(), 0)
		}
	}

	// --- Tier 3: Strategist ---
	lastStrategistRun, _ := h.RedisClient.Get(ctx, "analyst:last_run:strategist").Result()
	lastStratTS, _ := strconv.ParseInt(lastStrategistRun, 10, 64)

	if time.Since(time.Unix(lastStratTS, 0)) >= 1*time.Hour {
		utils.ReportProcess(ctx, h.RedisClient, h.DiscordClient, "system-analyst", "Tier 3: Strategist Analysis")

		roadmapItem := h.fetchOldestPublishedRoadmapItem(ctx)
		var roadmapContent string
		if roadmapItem != nil {
			roadmapContent = roadmapItem.Content
			log.Printf("[%s] Found active roadmap objective: \"%s\".", HandlerName, roadmapItem.ID)
		}

		strategistPrompt := h.buildAnalysisPrompt(events, history, status, logs, tests, "strategist")
		if roadmapContent != "" {
			strategistPrompt = fmt.Sprintf("### PRIMARY CREATOR OBJECTIVE (PRIORITY #1):\n%s\n\n%s", roadmapContent, strategistPrompt)
		}

		log.Printf("[%s] Executing Tier 3 (Strategist) Analysis...", HandlerName)

		strategistModel := "dex-analyst-strategist"
		ollamaSResponse, err := h.OllamaClient.Generate(strategistModel, strategistPrompt, nil)
		if err == nil {
			h.emitAudit(ctx, "strategist", strategistModel, strategistPrompt, ollamaSResponse)
			sResults := h.parseAnalysisResults(ollamaSResponse)

			if roadmapItem != nil && len(sResults) > 0 {
				roadmapItem.State = types.RoadmapStateConsumed
				roadmapItem.ConsumedAt = time.Now().Unix()
				h.updateRoadmapItem(ctx, roadmapItem)
			}

			allResults = append(allResults, sResults...)
			h.RedisClient.Set(ctx, "analyst:last_run:strategist", time.Now().Unix(), 0)
		}
	}

	return allResults, nil
}

func (h *AnalystHandler) parseAnalysisResults(response string) []AnalysisResult {
	if strings.Contains(response, "No significant insights found.") {
		return nil
	}

	var results []AnalysisResult
	sections := strings.Split(response, "---")
	for _, section := range sections {
		res := h.parseSingleMarkdownReport(section)
		if res.Title != "" {
			results = append(results, res)
		}
	}
	return results
}

func (h *AnalystHandler) parseSingleMarkdownReport(input string) AnalysisResult {
	var res AnalysisResult
	lines := strings.Split(input, "\n")

	var currentSection string
	var contentLines []string
	var pathLines []string
	var summaryLines []string
	foundHeader := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Ignore everything until we find the first header (#)
		if !foundHeader {
			if strings.HasPrefix(trimmed, "# ") {
				res.Title = strings.TrimPrefix(trimmed, "# ")
				foundHeader = true
			}
			continue
		}

		// If we've already found the header, parse metadata and sections
		if strings.HasPrefix(trimmed, "**Type**:") {
			res.Type = strings.ToLower(strings.TrimSpace(strings.TrimPrefix(trimmed, "**Type**:")))
			continue
		}
		if strings.HasPrefix(trimmed, "**Priority**:") {
			res.Priority = strings.ToLower(strings.TrimSpace(strings.TrimPrefix(trimmed, "**Priority**:")))
			continue
		}
		if strings.HasPrefix(trimmed, "**Category**:") {
			res.Category = strings.ToLower(strings.TrimSpace(strings.TrimPrefix(trimmed, "**Category**:")))
			continue
		}
		if strings.HasPrefix(trimmed, "**Affected**:") {
			affectedRaw := strings.TrimSpace(strings.TrimPrefix(trimmed, "**Affected**:"))
			parts := strings.Split(affectedRaw, ",")
			for _, p := range parts {
				p = strings.TrimSpace(p)
				if p != "" {
					res.AffectedServices = append(res.AffectedServices, p)
				}
			}
			continue
		}
		if strings.HasPrefix(trimmed, "**Related IDs**:") {
			idsRaw := strings.TrimSpace(strings.TrimPrefix(trimmed, "**Related IDs**:"))
			parts := strings.Split(idsRaw, ",")
			for _, p := range parts {
				p = strings.TrimSpace(p)
				if p != "" {
					res.RelatedEventIDs = append(res.RelatedEventIDs, p)
				}
			}
			continue
		}

		if strings.HasPrefix(trimmed, "## Summary") {
			currentSection = "summary"
			continue
		}
		if strings.HasPrefix(trimmed, "## Content") {
			currentSection = "content"
			continue
		}
		if strings.HasPrefix(trimmed, "## Implementation Path") {
			currentSection = "path"
			continue
		}

		switch currentSection {
		case "summary":
			summaryLines = append(summaryLines, line)
		case "content":
			contentLines = append(contentLines, line)
		case "path":
			if strings.HasPrefix(trimmed, "1.") || strings.HasPrefix(trimmed, "2.") ||
				strings.HasPrefix(trimmed, "3.") || strings.HasPrefix(trimmed, "4.") ||
				strings.HasPrefix(trimmed, "5.") || strings.HasPrefix(trimmed, "6.") ||
				strings.HasPrefix(trimmed, "7.") || strings.HasPrefix(trimmed, "8.") ||
				strings.HasPrefix(trimmed, "9.") || strings.HasPrefix(trimmed, "-") ||
				strings.HasPrefix(trimmed, "*") {

				var cleaned string
				if idx := strings.Index(trimmed, "."); idx != -1 && idx < 3 {
					cleaned = strings.TrimSpace(trimmed[idx+1:])
				} else {
					cleaned = strings.TrimSpace(strings.TrimPrefix(strings.TrimPrefix(trimmed, "-"), "*"))
				}
				if cleaned != "" {
					pathLines = append(pathLines, cleaned)
				}
			}
		}
	}

	res.Summary = strings.TrimSpace(strings.Join(summaryLines, "\n"))
	res.Content = strings.TrimSpace(strings.Join(contentLines, "\n"))
	res.ImplementationPath = pathLines

	if res.Type != "blueprint" {
		res.Body = res.Content
		if res.Body == "" {
			res.Body = res.Summary
		}
	} else {
		res.Body = res.Summary
	}

	return res
}

func (h *AnalystHandler) emitAudit(ctx context.Context, tier, model, input, output string) {
	eventID := uuid.New().String()
	timestamp := time.Now().Unix()

	payload := map[string]interface{}{
		"type":       string(types.EventTypeSystemAnalysisAudit),
		"tier":       tier,
		"model":      model,
		"raw_input":  input,
		"raw_output": output,
		"timestamp":  timestamp,
	}

	eventJSON, _ := json.Marshal(payload)
	event := types.Event{
		ID:        eventID,
		Service:   HandlerName,
		Event:     eventJSON,
		Timestamp: timestamp,
	}
	fullEventJSON, _ := json.Marshal(event)
	pipe := h.RedisClient.Pipeline()
	pipe.Set(ctx, "event:"+eventID, fullEventJSON, 0)
	pipe.ZAdd(ctx, "events:timeline", redis.Z{Score: float64(timestamp), Member: eventID})
	pipe.ZAdd(ctx, "events:service:"+HandlerName, redis.Z{Score: float64(timestamp), Member: eventID})
	_, _ = pipe.Exec(ctx)
}

func (h *AnalystHandler) fetchEventsForAnalysis(ctx context.Context, sinceTS, untilTS int64) ([]types.Event, error) {
	eventIDs, err := h.RedisClient.ZRangeByScore(ctx, "events:timeline", &redis.ZRangeBy{
		Min: fmt.Sprintf("%d", sinceTS+1),
		Max: fmt.Sprintf("%d", untilTS),
	}).Result()

	if err != nil || len(eventIDs) == 0 {
		return nil, err
	}

	ignoredEventTypes := []string{
		string(types.EventTypeCLIStatus),
		string(types.EventTypeMessagingBotStatusUpdate),
		string(types.EventTypeMessagingUserSpeakingStarted),
		string(types.EventTypeMessagingUserSpeakingStopped),
		string(types.EventTypeSystemAnalysisAudit),
	}

	events := make([]types.Event, 0, len(eventIDs))
	pipe := h.RedisClient.Pipeline()
	cmds := make([]*redis.StringCmd, len(eventIDs))
	for i, eventID := range eventIDs {
		cmds[i] = pipe.Get(ctx, "event:"+eventID)
	}
	_, _ = pipe.Exec(ctx)

	for _, cmd := range cmds {
		eventJSON, err := cmd.Result()
		if err != nil {
			continue
		}
		var event types.Event
		_ = json.Unmarshal([]byte(eventJSON), &event)

		var eventData map[string]interface{}
		if err := json.Unmarshal(event.Event, &eventData); err == nil {
			eventType, _ := eventData["type"].(string)
			if eventType == string(types.EventTypeSystemNotificationGenerated) || eventType == string(types.EventTypeSystemBlueprintGenerated) {
				continue
			}
			isIgnored := false
			for _, ignored := range ignoredEventTypes {
				if eventType == ignored {
					isIgnored = true
					break
				}
			}
			if isIgnored {
				continue
			}
		}
		events = append(events, event)
	}
	return events, nil
}

func (h *AnalystHandler) fetchSystemStatus() (string, error) {
	status, err := utils.FetchURL("http://127.0.0.1:8100/system_monitor", 5*time.Second)
	return status, err
}

func (h *AnalystHandler) fetchRecentLogs() (string, error) {
	logs, err := utils.FetchURL("http://127.0.0.1:8100/logs?limit=20", 5*time.Second)
	return logs, err
}

func (h *AnalystHandler) fetchTestResults() (string, error) {
	return "No recent test results available.", nil
}

func (h *AnalystHandler) fetchRecentNotifications(ctx context.Context, limit int) (string, error) {
	eventIDs, err := h.RedisClient.ZRevRange(ctx, "events:service:"+HandlerName, 0, int64(limit-1)).Result()
	if err != nil {
		return "", err
	}
	var history []string
	for _, id := range eventIDs {
		data, _ := h.RedisClient.Get(ctx, "event:"+id).Result()
		var e types.Event
		if err := json.Unmarshal([]byte(data), &e); err == nil {
			var ed map[string]interface{}
			_ = json.Unmarshal(e.Event, &ed)
			title, _ := ed["title"].(string)
			if title != "" {
				history = append(history, fmt.Sprintf("- %s", title))
			}
		}
	}
	return strings.Join(history, "\n"), nil
}

func (h *AnalystHandler) buildAnalysisPrompt(events []types.Event, history, status, logs, tests, tier string) string {
	var contextStr string
	switch tier {
	case "guardian":
		contextStr = utils.GetAnalystGuardianPrompt()
	case "architect":
		contextStr = utils.GetAnalystArchitectPrompt()
	case "strategist":
		contextStr = utils.GetAnalystStrategistPrompt()
	}

	var eventLines []string
	for _, e := range events {
		var ed map[string]interface{}
		_ = json.Unmarshal(e.Event, &ed)
		eventType, _ := ed["type"].(string)
		summary := templates.FormatEventAsText(eventType, ed, e.Service, e.Timestamp, 0, "UTC", "en")
		eventLines = append(eventLines, summary)
	}

	return fmt.Sprintf("%s\n\n### SYSTEM STATUS\n%s\n\n### RECENT LOGS\n%s\n\n### NEW EVENT LOGS\n%s\n\n### RECENT REPORTED ISSUES\n%s\n\n### TEST RESULTS\n%s",
		contextStr, status, logs, strings.Join(eventLines, "\n"), history, tests)
}

func (h *AnalystHandler) emitResult(ctx context.Context, res AnalysisResult) {
	eventID := uuid.New().String()
	timestamp := time.Now().Unix()

	var eventType string
	payload := map[string]interface{}{
		"title":             res.Title,
		"priority":          res.Priority,
		"category":          res.Category,
		"body":              res.Body,
		"related_event_ids": res.RelatedEventIDs,
		"read":              false,
	}

	switch res.Type {
	case "alert":
		eventType = string(types.EventTypeSystemNotificationGenerated)
		payload["alert"] = true
	case "blueprint":
		eventType = string(types.EventTypeSystemBlueprintGenerated)
		payload["summary"] = res.Summary
		payload["content"] = res.Content
		payload["affected_services"] = res.AffectedServices
		payload["implementation_path"] = res.ImplementationPath
	default:
		eventType = string(types.EventTypeSystemNotificationGenerated)
	}

	payload["type"] = eventType
	eventJSON, _ := json.Marshal(payload)
	event := types.Event{
		ID:        eventID,
		Service:   HandlerName,
		Event:     eventJSON,
		Timestamp: timestamp,
	}
	fullEventJSON, _ := json.Marshal(event)
	pipe := h.RedisClient.Pipeline()
	pipe.Set(ctx, "event:"+eventID, fullEventJSON, 0)
	pipe.ZAdd(ctx, "events:timeline", redis.Z{Score: float64(timestamp), Member: eventID})
	pipe.ZAdd(ctx, "events:service:"+HandlerName, redis.Z{Score: float64(timestamp), Member: eventID})
	_, _ = pipe.Exec(ctx)
	log.Printf("[%s] Emitted %s: \"%s\"", HandlerName, res.Type, res.Title)
}

func (h *AnalystHandler) fetchOldestPublishedRoadmapItem(ctx context.Context) *types.RoadmapItem {
	keys, err := h.RedisClient.Keys(ctx, "roadmap:*").Result()
	if err != nil || len(keys) == 0 {
		return nil
	}

	var items []types.RoadmapItem
	for _, key := range keys {
		data, err := h.RedisClient.Get(ctx, key).Result()
		if err != nil {
			continue
		}
		var item types.RoadmapItem
		if err := json.Unmarshal([]byte(data), &item); err == nil && item.State == types.RoadmapStatePublished {
			items = append(items, item)
		}
	}

	if len(items) == 0 {
		return nil
	}

	sort.Slice(items, func(i, j int) bool {
		return items[i].CreatedAt < items[j].CreatedAt
	})

	return &items[0]
}

func (h *AnalystHandler) updateRoadmapItem(ctx context.Context, item *types.RoadmapItem) {
	data, _ := json.Marshal(item)
	h.RedisClient.Set(ctx, "roadmap:"+item.ID, data, 0)
}
