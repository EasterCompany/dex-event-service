package guardian

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/EasterCompany/dex-event-service/internal/discord"
	"github.com/EasterCompany/dex-event-service/internal/ollama"
	"github.com/EasterCompany/dex-event-service/internal/web"
	"github.com/EasterCompany/dex-event-service/templates"
	"github.com/EasterCompany/dex-event-service/types"
	"github.com/EasterCompany/dex-event-service/utils"
	"github.com/google/uuid"
	"github.com/redis/go-redis/v9"
)

const (
	HandlerName     = "guardian-handler"
	LastRunKeyT1    = "guardian:last_run:t1"
	LastRunKeyT2    = "guardian:last_run:t2"
	ProcessID       = "system-guardian"
	DefaultModelT1  = "dex-guardian-t1"
	DefaultModelT2  = "dex-guardian-t2"
	T1Cooldown      = 1800 // 30 minutes
	T2Cooldown      = 1800 // 30 minutes
	IdleRequirement = 300  // 5 minutes
)

// getDexBinaryPath returns the absolute path to the dex binary in the user's home directory.
func getDexBinaryPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return "dex"
	}
	return filepath.Join(home, "Dexter", "bin", "dex")
}

// AnalysisResult represents a single insight or blueprint generated by the model.
type AnalysisResult struct {
	Type               string   `json:"type"` // alert, notification, blueprint
	Title              string   `json:"title"`
	Priority           string   `json:"priority"`
	Category           string   `json:"category"`
	Body               string   `json:"body"`
	Summary            string   `json:"summary"`
	Content            string   `json:"content"`
	AffectedServices   []string `json:"affected_services"`
	ImplementationPath []string `json:"implementation_path"`
	RelatedEventIDs    []string `json:"related_event_ids"`
	AuditEventID       string   `json:"audit_event_id,omitempty"`
}

type GuardianHandler struct {
	RedisClient   *redis.Client
	OllamaClient  *ollama.Client
	DiscordClient *discord.Client
	WebClient     *web.Client
	ChatManager   *utils.ChatContextManager
	stopChan      chan struct{}
	ctx           context.Context
	cancel        context.CancelFunc
}

func NewGuardianHandler(redis *redis.Client, ollama *ollama.Client, discord *discord.Client, web *web.Client, options interface{}) *GuardianHandler {
	ctx, cancel := context.WithCancel(context.Background())
	return &GuardianHandler{
		RedisClient:   redis,
		OllamaClient:  ollama,
		DiscordClient: discord,
		WebClient:     web,
		ChatManager:   utils.NewChatContextManager(redis),
		ctx:           ctx,
		cancel:        cancel,
	}
}

func (h *GuardianHandler) Init(ctx context.Context) error {
	h.stopChan = make(chan struct{})
	go h.runWorker()
	log.Printf("[%s] Background worker started.", HandlerName)
	return nil
}

func (h *GuardianHandler) Close() error {
	if h.cancel != nil {
		h.cancel()
	}
	if h.stopChan != nil {
		close(h.stopChan)
	}
	utils.ClearProcess(context.Background(), h.RedisClient, h.DiscordClient, ProcessID)
	return nil
}

func (h *GuardianHandler) HandleEvent(ctx context.Context, event *types.Event) error {
	return nil
}

func (h *GuardianHandler) runWorker() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-h.stopChan:
			return
		case <-ticker.C:
			h.checkAndAnalyze()
		}
	}
}

func (h *GuardianHandler) checkAndAnalyze() {
	ctx := h.ctx
	now := time.Now().Unix()

	// 1. System Idle Requirement
	lastCognitiveEvent, _ := h.RedisClient.Get(ctx, "system:last_cognitive_event").Int64()
	if now-lastCognitiveEvent < IdleRequirement {
		return
	}

	// 2. No ongoing processes (True Busy Check)
	if h.isActuallyBusy(ctx) {
		return
	}

	// 3. Already running check
	activeTier, _ := h.RedisClient.Get(ctx, "guardian:active_tier").Result()
	if activeTier != "" {
		return
	}

	// 4. Busy Count Cleanup (Self-healing)
	h.cleanupBusyCount(ctx)

	// 4. Both Tiers must be off cooldown for automated whole-agent run
	lastT1, _ := h.RedisClient.Get(ctx, LastRunKeyT1).Int64()
	lastT2, _ := h.RedisClient.Get(ctx, LastRunKeyT2).Int64()

	if (now-lastT1 < T1Cooldown) || (now-lastT2 < T2Cooldown) {
		return
	}

	// Trigger full analysis (Tier 1 then Tier 2)
	results, err := h.PerformAnalysis(ctx, 0) // 0 = all
	if err != nil {
		log.Printf("[%s] Automated analysis failed: %v", HandlerName, err)
		return
	}

	for _, res := range results {
		_, _ = h.emitResult(ctx, res)
	}
}

// isActuallyBusy scans for active process keys and ignores persistent/meta processes.
func (h *GuardianHandler) isActuallyBusy(ctx context.Context) bool {
	keys, err := h.RedisClient.Keys(ctx, "process:info:*").Result()
	if err != nil {
		return false
	}

	for _, k := range keys {
		// Ignore ourselves
		if strings.HasSuffix(k, ":"+ProcessID) {
			continue
		}
		// If ANY other process exists, we are busy
		return true
	}

	return false
}

// cleanupBusyCount resyncs the busy_ref_count metric if it drifts from the actual number of process keys.
func (h *GuardianHandler) cleanupBusyCount(ctx context.Context) {
	keys, _ := h.RedisClient.Keys(ctx, "process:info:*").Result()
	actualCount := len(keys)

	currentCount, _ := h.RedisClient.Get(ctx, "system:busy_ref_count").Int()
	if actualCount != currentCount {
		log.Printf("[%s] Resyncing busy_ref_count: %d -> %d", HandlerName, currentCount, actualCount)
		h.RedisClient.Set(ctx, "system:busy_ref_count", actualCount, 0)
		if actualCount == 0 {
			h.RedisClient.Set(ctx, "system:state", "idle", 0)
			h.RedisClient.Set(ctx, "system:last_transition_ts", time.Now().Unix(), 0)
		} else {
			h.RedisClient.Set(ctx, "system:state", "busy", 0)
		}
	}
}

func (h *GuardianHandler) runSystemTests(ctx context.Context) {
	h.RedisClient.Set(ctx, "guardian:active_tier", "tests", utils.DefaultTTL)
	utils.ReportProcess(ctx, h.RedisClient, h.DiscordClient, ProcessID, "Running System Tests")

	testCtx, cancel := context.WithTimeout(ctx, 15*time.Minute)
	defer cancel()

	dexPath := getDexBinaryPath()
	cmd := exec.CommandContext(testCtx, dexPath, "test")
	_ = cmd.Run() // Results are emitted as events by dex test itself
}

func (h *GuardianHandler) PerformAnalysis(ctx context.Context, tier int) ([]AnalysisResult, error) {
	log.Printf("[%s] Starting Guardian Analysis (Tier: %d)", HandlerName, tier)

	// Clear active tier and process on exit
	defer h.RedisClient.Del(ctx, "guardian:active_tier")
	defer utils.ClearProcess(ctx, h.RedisClient, h.DiscordClient, ProcessID)

	// Run tests for T1 input
	if tier == 0 || tier == 1 {
		h.runSystemTests(ctx)
	}

	var allResults []AnalysisResult

	// Tier 1: Technical Sentry
	if tier == 0 || tier == 1 {
		h.RedisClient.Set(ctx, "guardian:active_tier", "t1", utils.DefaultTTL)
		utils.ReportProcess(ctx, h.RedisClient, h.DiscordClient, ProcessID, "Tier 1: Technical Sentry")

		// Gather context for T1
		events, _ := h.fetchEventsForAnalysis(ctx)
		status, _ := h.fetchSystemStatus(ctx)
		systemInfo, _ := h.fetchSystemHardware(ctx)
		logs, _ := h.fetchRecentLogs(ctx)
		tests, _ := h.fetchTestResults(ctx)
		history, _ := h.fetchRecentNotifications(ctx, 20)

		t1Results, err := h.runTierAnalysis(ctx, "t1", events, history, status, systemInfo, logs, tests)
		if err == nil {
			allResults = append(allResults, t1Results...)
			h.RedisClient.Set(ctx, LastRunKeyT1, time.Now().Unix(), 0)
		} else {
			log.Printf("[%s] Tier 1 analysis failed: %v", HandlerName, err)
		}
	}

	// Tier 2: Architect
	if tier == 0 || tier == 2 {
		h.RedisClient.Set(ctx, "guardian:active_tier", "t2", utils.DefaultTTL)
		utils.ReportProcess(ctx, h.RedisClient, h.DiscordClient, ProcessID, "Tier 2: Architect Analysis")

		// T2 takes T1 reports as input if running both
		var t1Context string
		if len(allResults) > 0 {
			t1JSON, _ := json.Marshal(allResults)
			t1Context = "\n\n### RECENT TIER 1 REPORTS:\n" + string(t1JSON)
		}

		// Gather context for T2
		status, _ := h.fetchSystemStatus(ctx)
		logs, _ := h.fetchRecentLogs(ctx)
		tests, _ := h.fetchTestResults(ctx)
		history, _ := h.fetchRecentNotifications(ctx, 20)

		t2Results, err := h.runTierAnalysis(ctx, "t2", nil, history, status, t1Context, logs, tests)
		if err == nil {
			allResults = append(allResults, t2Results...)
			h.RedisClient.Set(ctx, LastRunKeyT2, time.Now().Unix(), 0)
		} else {
			log.Printf("[%s] Tier 2 analysis failed: %v", HandlerName, err)
		}
	}

	return allResults, nil
}

func (h *GuardianHandler) runTierAnalysis(ctx context.Context, tier string, events []types.Event, history, status, systemInfo, logs, tests string) ([]AnalysisResult, error) {
	var model, systemPrompt string
	sessionID := tier

	switch tier {
	case "t1":
		model = DefaultModelT1
		systemPrompt = utils.GetGuardianTier1Prompt()
	case "t2":
		model = DefaultModelT2
		systemPrompt = utils.GetGuardianTier2Prompt()
	default:
		return nil, fmt.Errorf("unknown tier: %s", tier)
	}

	chatHistory, _ := h.ChatManager.LoadHistory(ctx, sessionID)
	if len(chatHistory) == 0 || chatHistory[0].Role != "system" {
		chatHistory = append([]ollama.Message{{Role: "system", Content: systemPrompt}}, chatHistory...)
	} else {
		chatHistory[0].Content = systemPrompt
	}

	// Context Construction
	var eventData string
	if len(events) > 0 {
		var lines []string
		for _, e := range events {
			var ed map[string]interface{}
			_ = json.Unmarshal(e.Event, &ed)
			lines = append(lines, templates.FormatEventAsText(ed["type"].(string), ed, e.Service, e.Timestamp, 0, "UTC", "en"))
		}
		eventData = "\n\n### RECENT EVENTS:\n" + strings.Join(lines, "\n")
	}

	// Dynamic Context Injection
	cliHelp, _ := h.fetchCLICapabilities(ctx)
	inputContext := fmt.Sprintf("### SYSTEM STATUS\n%s\n\n### CLI CAPABILITIES\n%s\n\n### HARDWARE & CONTEXT\n%s\n\n### RECENT LOGS\n%s\n\n### TEST RESULTS\n%s%s\n\n### REPORTED ISSUES HISTORY\n%s",
		status, cliHelp, systemInfo, logs, tests, eventData, history)

	newUserMsg := ollama.Message{Role: "user", Content: inputContext}
	currentTurnHistory := append(chatHistory, newUserMsg)

	startTime := time.Now().Unix()
	totalWaste := int64(0)
	maxRetries := 3

	for i := 0; i < maxRetries; i++ {
		attStart := time.Now().Unix()
		tCtx, cancel := context.WithTimeout(ctx, 5*time.Minute)
		respMsg, err := h.OllamaClient.Chat(tCtx, model, currentTurnHistory)
		cancel()

		attDur := time.Now().Unix() - attStart
		if err != nil {
			totalWaste += attDur
			h.RedisClient.Incr(ctx, "system:metrics:model:"+model+":failures")
			h.RedisClient.IncrBy(ctx, "system:metrics:total_waste_seconds", attDur)
			continue
		}

		results := h.parseAnalysisResults(respMsg.Content)
		if len(results) > 0 || strings.Contains(respMsg.Content, "No significant insights found") || strings.Contains(respMsg.Content, "<NO_ISSUES/>") {
			// Success
			activeDur := time.Now().Unix() - startTime - totalWaste
			h.RedisClient.Incr(ctx, "system:metrics:model:"+model+":attempts")
			auditID, _ := h.emitAuditExtended(ctx, tier, model, inputContext, respMsg.Content, activeDur, totalWaste, i+1, i, false)

			for j := range results {
				results[j].AuditEventID = auditID
			}

			_ = h.ChatManager.AppendMessage(ctx, sessionID, newUserMsg)
			_ = h.ChatManager.AppendMessage(ctx, sessionID, respMsg)
			return results, nil
		}

		// Malformed
		totalWaste += attDur
		h.RedisClient.Incr(ctx, "system:metrics:model:"+model+":failures")
		h.RedisClient.IncrBy(ctx, "system:metrics:total_waste_seconds", attDur)

		currentTurnHistory = append(currentTurnHistory, respMsg)
		currentTurnHistory = append(currentTurnHistory, ollama.Message{
			Role:    "user",
			Content: "SYSTEM ERROR: Your response did not follow the strict 'Dexter Report' format. Fix it immediately.",
		})
	}

	h.RedisClient.Incr(ctx, "system:metrics:model:"+model+":absolute_failures")
	_, _ = h.emitAuditExtended(ctx, tier, model, inputContext, "ABSOLUTE FAILURE", 0, totalWaste, maxRetries, maxRetries, true)
	return nil, fmt.Errorf("max retries reached for tier %s", tier)
}

func (h *GuardianHandler) parseAnalysisResults(response string) []AnalysisResult {
	if strings.Contains(response, "No significant insights found") || strings.Contains(response, "<NO_ISSUES/>") {
		return nil
	}
	var results []AnalysisResult
	re := regexp.MustCompile(`(?m)^\s*---\s*$`)
SectionLoop:
	for _, section := range re.Split(response, -1) {
		res := h.parseSingleMarkdownReport(section)
		if res.Title == "" {
			continue SectionLoop
		}
		results = append(results, res)
	}
	return results
}

func (h *GuardianHandler) parseSingleMarkdownReport(input string) AnalysisResult {
	var res AnalysisResult
	lines := strings.Split(input, "\n")
	var currentSection string
	var contentLines, pathLines, summaryLines []string

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "" {
			continue
		}

		if strings.HasPrefix(trimmed, "# ") {
			res.Title = strings.TrimPrefix(trimmed, "# ")
			if strings.Contains(strings.ToUpper(res.Title), "[BLUEPRINT]") {
				res.Type = "blueprint"
				res.Title = strings.TrimSpace(strings.Replace(strings.ToUpper(res.Title), "[BLUEPRINT]", "", 1))
			}
			continue
		}

		lower := strings.ToLower(trimmed)
		if strings.HasPrefix(lower, "**type**:") {
			res.Type = strings.TrimSpace(trimmed[strings.Index(trimmed, ":")+1:])
			continue
		}
		if strings.HasPrefix(lower, "**priority**:") {
			res.Priority = strings.TrimSpace(trimmed[strings.Index(trimmed, ":")+1:])
			continue
		}
		if strings.HasPrefix(lower, "**category**:") {
			res.Category = strings.TrimSpace(trimmed[strings.Index(trimmed, ":")+1:])
			continue
		}
		if strings.HasPrefix(lower, "**affected**:") || strings.HasPrefix(lower, "**affected services**:") {
			res.AffectedServices = strings.Split(strings.TrimSpace(trimmed[strings.Index(trimmed, ":")+1:]), ",")
			continue
		}

		if strings.Contains(lower, "summary") {
			currentSection = "summary"
			continue
		}
		if strings.Contains(lower, "content") || strings.Contains(lower, "insight") || strings.Contains(lower, "body") {
			currentSection = "content"
			continue
		}
		if strings.Contains(lower, "implementation path") {
			currentSection = "path"
			continue
		}

		switch currentSection {
		case "summary":
			summaryLines = append(summaryLines, trimmed)
		case "content":
			contentLines = append(contentLines, trimmed)
		case "path":
			if strings.HasPrefix(trimmed, "-") || strings.HasPrefix(trimmed, "*") || (len(trimmed) > 2 && trimmed[1] == '.') {
				pathLines = append(pathLines, trimmed)
			}
		}
	}

	res.Summary = strings.Join(summaryLines, " ")
	res.Content = strings.Join(contentLines, "\n")
	res.ImplementationPath = pathLines
	if res.Type != "blueprint" {
		res.Body = res.Content
		if res.Body == "" {
			res.Body = res.Summary
		}
	} else {
		res.Body = res.Summary
	}
	return res
}

func (h *GuardianHandler) emitAuditExtended(ctx context.Context, tier, model, input, output string, duration, waste int64, attempts, failures int, absolute bool) (string, error) {
	eventID := uuid.New().String()
	timestamp := time.Now().Unix()
	if duration > 0 {
		h.RedisClient.IncrBy(ctx, "system:metrics:cognitive_active_seconds", duration)
	}
	payload := map[string]interface{}{
		"type": string(types.EventTypeSystemAnalysisAudit),
		"tier": tier, "model": model, "raw_input": input, "raw_output": output,
		"duration": duration, "wasted_seconds": waste, "attempts_count": attempts,
		"failure_count": failures, "is_absolute_failure": absolute, "timestamp": timestamp,
	}
	eventJSON, _ := json.Marshal(payload)
	event := types.Event{ID: eventID, Service: HandlerName, Event: eventJSON, Timestamp: timestamp}
	fullJSON, _ := json.Marshal(event)
	pipe := h.RedisClient.Pipeline()
	pipe.Set(ctx, "event:"+eventID, fullJSON, utils.DefaultTTL)
	pipe.ZAdd(ctx, "events:timeline", redis.Z{Score: float64(timestamp), Member: eventID})
	pipe.ZAdd(ctx, "events:service:"+HandlerName, redis.Z{Score: float64(timestamp), Member: eventID})
	_, err := pipe.Exec(ctx)
	return eventID, err
}

func (h *GuardianHandler) emitResult(ctx context.Context, res AnalysisResult) (string, error) {
	eventID := uuid.New().String()
	timestamp := time.Now().Unix()
	payload := map[string]interface{}{
		"title": res.Title, "priority": res.Priority, "category": res.Category,
		"body": res.Body, "related_event_ids": res.RelatedEventIDs, "read": false,
	}
	if res.AuditEventID != "" {
		payload["audit_event_id"] = res.AuditEventID
	}
	var eventType string
	if res.Type == "blueprint" {
		eventType = string(types.EventTypeSystemBlueprintGenerated)
		payload["summary"] = res.Summary
		payload["content"] = res.Content
		payload["affected_services"] = res.AffectedServices
		payload["implementation_path"] = res.ImplementationPath
	} else {
		eventType = string(types.EventTypeSystemNotificationGenerated)
		if res.Type == "alert" || res.Priority == "high" || res.Priority == "critical" {
			payload["alert"] = true
		}
	}
	payload["type"] = eventType
	eventJSON, _ := json.Marshal(payload)
	event := types.Event{ID: eventID, Service: HandlerName, Event: eventJSON, Timestamp: timestamp}
	fullJSON, _ := json.Marshal(event)
	pipe := h.RedisClient.Pipeline()
	pipe.Set(ctx, "event:"+eventID, fullJSON, utils.DefaultTTL)
	pipe.ZAdd(ctx, "events:timeline", redis.Z{Score: float64(timestamp), Member: eventID})
	pipe.ZAdd(ctx, "events:service:"+HandlerName, redis.Z{Score: float64(timestamp), Member: eventID})
	_, err := pipe.Exec(ctx)
	return eventID, err
}

func (h *GuardianHandler) fetchEventsForAnalysis(ctx context.Context) ([]types.Event, error) {
	eventIDs, _ := h.RedisClient.ZRevRange(ctx, "events:timeline", 0, 50).Result()
	var events []types.Event
	for _, id := range eventIDs {
		val, _ := h.RedisClient.Get(ctx, "event:"+id).Result()
		var e types.Event
		if err := json.Unmarshal([]byte(val), &e); err == nil {
			if e.Service == "dex-discord-service" {
				continue
			}
			events = append(events, e)
		}
	}
	return events, nil
}

func (h *GuardianHandler) fetchSystemStatus(ctx context.Context) (string, error) {
	dexPath := getDexBinaryPath()
	cmd := exec.CommandContext(ctx, dexPath, "status")
	out, _ := cmd.CombinedOutput()
	return utils.StripANSI(string(out)), nil
}

func (h *GuardianHandler) fetchSystemHardware(ctx context.Context) (string, error) {
	dexPath := getDexBinaryPath()
	cmd := exec.CommandContext(ctx, dexPath, "system")
	out, _ := cmd.CombinedOutput()
	return utils.StripANSI(string(out)), nil
}

func (h *GuardianHandler) fetchRecentLogs(ctx context.Context) (string, error) {
	dexPath := getDexBinaryPath()
	cmd := exec.CommandContext(ctx, dexPath, "logs")
	out, _ := cmd.CombinedOutput()
	return utils.StripANSI(string(out)), nil
}

func (h *GuardianHandler) fetchTestResults(ctx context.Context) (string, error) {
	eventIDs, _ := h.RedisClient.ZRevRange(ctx, "events:timeline", 0, 250).Result()
	var tests []string
	seen := make(map[string]bool)
	for _, id := range eventIDs {
		data, _ := h.RedisClient.Get(ctx, "event:"+id).Result()
		var e types.Event
		if err := json.Unmarshal([]byte(data), &e); err == nil {
			var ed map[string]interface{}
			_ = json.Unmarshal(e.Event, &ed)
			if ed["type"] == string(types.EventTypeSystemTestCompleted) {
				svc, _ := ed["service_name"].(string)
				if svc != "" && !seen[svc] {
					fmtStr := fmt.Sprintf("[%s] %s", svc, ed["duration"])
					tests = append(tests, fmtStr)
					seen[svc] = true
				}
			}
		}
	}
	return strings.Join(tests, "\n"), nil
}

func (h *GuardianHandler) fetchRecentNotifications(ctx context.Context, limit int) (string, error) {
	ids, _ := h.RedisClient.ZRevRange(ctx, "events:service:"+HandlerName, 0, int64(limit-1)).Result()
	var history []string
	for _, id := range ids {
		data, _ := h.RedisClient.Get(ctx, "event:"+id).Result()
		var e types.Event
		if err := json.Unmarshal([]byte(data), &e); err == nil {
			var ed map[string]interface{}
			_ = json.Unmarshal(e.Event, &ed)
			if title, ok := ed["title"].(string); ok {
				history = append(history, "- "+title)
			}
		}
	}
	return strings.Join(history, "\n"), nil
}

func (h *GuardianHandler) fetchCLICapabilities(ctx context.Context) (string, error) {
	dexPath := getDexBinaryPath()
	cmd := exec.CommandContext(ctx, dexPath, "help")
	out, _ := cmd.CombinedOutput()
	return utils.StripANSI(string(out)), nil
}
