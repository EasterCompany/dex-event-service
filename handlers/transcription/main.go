package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"strings"

	"golang.org/x/term"
)

// HandlerInput represents the structure of the incoming event
type HandlerInput struct {
	EventID   string                 `json:"event_id"`
	Service   string                 `json:"service"`
	EventType string                 `json:"event_type"`
	EventData map[string]interface{} `json:"event_data"`
	Timestamp int64                  `json:"timestamp"`
}

// HandlerOutputEvent represents an event generated by this handler
type HandlerOutputEvent struct {
	Type string                 `json:"type"`
	Data map[string]interface{} `json:"data"`
}

// HandlerOutput represents the final JSON output
type HandlerOutput struct {
	Success bool                 `json:"success"`
	Error   string               `json:"error,omitempty"`
	Events  []HandlerOutputEvent `json:"events,omitempty"`
}

func createEvent(eventType string, data map[string]interface{}) HandlerOutputEvent {
	return HandlerOutputEvent{Type: eventType, Data: data}
}

func logEvent(msg string) HandlerOutputEvent {
	return createEvent("log_entry", map[string]interface{}{
		"level":   "info",
		"message": msg,
	})
}

func getRecentEvents() string {
	resp, err := http.Get("http://localhost:8100/events?ml=50&format=text")
	if err != nil {
		return "" // Fail silently, just no context
	}
	defer func() { _ = resp.Body.Close() }()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return ""
	}
	return string(body)
}

func queryOllama(model string, prompt string) (string, error) {
	body := map[string]interface{}{
		"model":  model,
		"prompt": prompt,
		"stream": false,
	}
	jsonBody, _ := json.Marshal(body)

	cmd := exec.Command("curl", "-s", "-X", "POST", "http://127.0.0.1:11434/api/generate", "-d", string(jsonBody))
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("ollama request failed: %w", err)
	}

	var resp struct {
		Response string `json:"response"`
	}
	if err := json.Unmarshal(output, &resp); err != nil {
		return "", fmt.Errorf("failed to parse ollama response: %v", err)
	}
	return resp.Response, nil
}

func checkEngagement(text string, context string) (bool, string, error) {
	prompt := fmt.Sprintf("Recent Context:\n%s\n\nNew Input: %s\n\nShould I engage? Reply only TRUE or FALSE.", context, text)
	response, err := queryOllama("dex-engagement-model", prompt)
	if err != nil {
		return false, "", err
	}

	cleaned := strings.TrimSpace(strings.ToUpper(response))
	// Basic robust parsing
	engaged := strings.Contains(cleaned, "TRUE")
	return engaged, response, nil
}

func generateResponse(text string, context string) (string, error) {
	prompt := fmt.Sprintf("Recent Context:\n%s\n\nUser Input: %s\n\nGenerate a response as Dexter:", context, text)
	return queryOllama("dex-chat-model", prompt)
}

func main() {
	// Check if stdin is a terminal
	if term.IsTerminal(int(os.Stdin.Fd())) {
		fmt.Println("Event Transcription Handler")
		fmt.Println("Reads transcription events and triggers chat response if engaged.")
		os.Exit(0)
	}

	var output HandlerOutput
	output.Success = true // Default to true unless fatal error

	// Read input
	inputData, err := io.ReadAll(os.Stdin)
	if err != nil {
		output.Success = false
		output.Error = fmt.Sprintf("Failed to read input: %v", err)
		_ = json.NewEncoder(os.Stdout).Encode(output)
		return
	}

	var input HandlerInput
	if err := json.Unmarshal(inputData, &input); err != nil {
		output.Success = false
		output.Error = fmt.Sprintf("Failed to parse input: %v", err)
		_ = json.NewEncoder(os.Stdout).Encode(output)
		return
	}

	// Verify event type
	if input.EventType != "transcription" && input.EventType != "message.transcribed" && input.EventType != "voice_transcribed" && input.EventType != "messaging.user.transcribed" {
		_ = json.NewEncoder(os.Stdout).Encode(output)
		return
	}

	// Extract transcription text
	transcription, ok := input.EventData["transcription"].(string)
	if !ok || transcription == "" {
		output.Events = append(output.Events, logEvent("Skipping empty transcription"))
		_ = json.NewEncoder(os.Stdout).Encode(output)
		return
	}

	// Check engagement
	recentEvents := getRecentEvents()
	engaged, reason, err := checkEngagement(transcription, recentEvents)

	if err != nil {
		output.Events = append(output.Events, createEvent("error_occurred", map[string]interface{}{
			"error": fmt.Sprintf("Engagement check failed: %v", err),
		}))
	} else {
		// Create engagement decision event
		decisionStr := "FALSE"
		if engaged {
			decisionStr = "TRUE"
		}
		output.Events = append(output.Events, createEvent("engagement_decision", map[string]interface{}{
			"decision": decisionStr,
			"reason":   reason, // Raw output from model can serve as reason/debug
			"context":  "Analyzed recent events vs new transcription",
		}))

		if engaged {
			// Generate response
			response, err := generateResponse(transcription, recentEvents)
			if err != nil {
				output.Events = append(output.Events, createEvent("error_occurred", map[string]interface{}{
					"error": fmt.Sprintf("Response generation failed: %v", err),
				}))
			} else {
				// Create bot response event
				output.Events = append(output.Events, createEvent("bot_response", map[string]interface{}{
					"response":       response,
					"target_user":    input.EventData["user_id"],
					"target_channel": input.EventData["channel_id"],
				}))
			}
		}
	}

	// Output result
	if err := json.NewEncoder(os.Stdout).Encode(output); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to write output: %v\n", err)
		os.Exit(1)
	}
}
