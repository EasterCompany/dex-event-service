package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"time"

	"golang.org/x/term"
)

// HandlerInput represents the structure of the incoming event
type HandlerInput struct {
	EventID   string                 `json:"event_id"`
	Service   string                 `json:"service"`
	EventType string                 `json:"event_type"`
	EventData map[string]interface{} `json:"event_data"`
	Timestamp int64                  `json:"timestamp"`
}

// HandlerOutputEvent represents an event generated by this handler
type HandlerOutputEvent struct {
	Type string                 `json:"type"`
	Data map[string]interface{} `json:"data"`
}

// HandlerOutput represents the final JSON output
type HandlerOutput struct {
	Success bool                 `json:"success"`
	Error   string               `json:"error,omitempty"`
	Events  []HandlerOutputEvent `json:"events,omitempty"`
}

func createEvent(eventType string, data map[string]interface{}) HandlerOutputEvent {
	return HandlerOutputEvent{Type: eventType, Data: data}
}

func logEvent(msg string) HandlerOutputEvent {
	return createEvent("log_entry", map[string]interface{}{
		"level":   "info",
		"message": msg,
	})
}

func getRecentEvents() string {
	resp, err := http.Get("http://localhost:8100/events?ml=50&format=text")
	if err != nil {
		return "" // Fail silently, just no context
	}
	defer func() { _ = resp.Body.Close() }()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return ""
	}
	return string(body)
}

func checkEngagement(text string, context string) (bool, error) {
	// Call 'dex ollama generate' (we can assume this command exists or use raw API)
	// Wait, dex-cli has 'dex ollama' but 'generate' isn't a subcommand I implemented recently?
	// 'dex ollama' has 'pull'. 'generate' might be useful to add to dex-cli, or I can use curl.
	// Actually, I can use the raw API via curl, OR I can use the 'dex' CLI if I add 'generate' or 'ask'.

	// Current dex-cli has 'ollama' command with 'pull'.
	// It does NOT have a generic 'ask' command exposed to CLI users easily?
	// dex-discord-service used `dex whisper transcribe`.

	// Let's check dex-cli/cmd/ollama.go.

	// For now, I'll use `curl` to talk to Ollama directly. It's safer than relying on CLI features I haven't built yet.
	// Ollama URL: http://127.0.0.1:11434/api/generate

	prompt := fmt.Sprintf("Recent Context:\n%s\n\nNew Input: %s", context, text)
	// JSON body
	body := map[string]interface{}{
		"model":  "dex-engagement-model",
		"prompt": prompt,
		"stream": false,
	}
	jsonBody, _ := json.Marshal(body)

	// Use curl
	// curl -X POST http://127.0.0.1:11434/api/generate -d '...'
	cmd := exec.Command("curl", "-s", "-X", "POST", "http://127.0.0.1:11434/api/generate", "-d", string(jsonBody))
	output, err := cmd.CombinedOutput()
	if err != nil {
		return false, fmt.Errorf("ollama request failed: %v", err)
	}

	// Parse response
	var resp struct {
		Response string `json:"response"`
	}
	if err := json.Unmarshal(output, &resp); err != nil {
		return false, fmt.Errorf("failed to parse ollama response: %v", err)
	}

	cleaned := strings.TrimSpace(strings.ToUpper(resp.Response))
	return cleaned == "TRUE", nil
}

func main() {
	// Check if stdin is a terminal
	if term.IsTerminal(int(os.Stdin.Fd())) {
		fmt.Println("Event Transcription Handler")
		fmt.Println("Reads transcription events and triggers chat response if engaged.")
		os.Exit(0)
	}

	var output HandlerOutput
	output.Success = true // Default to true unless fatal error

	// Read input
	inputData, err := io.ReadAll(os.Stdin)
	if err != nil {
		output.Success = false
		output.Error = fmt.Sprintf("Failed to read input: %v", err)
		_ = json.NewEncoder(os.Stdout).Encode(output)
		return
	}

	var input HandlerInput
	if err := json.Unmarshal(inputData, &input); err != nil {
		output.Success = false
		output.Error = fmt.Sprintf("Failed to parse input: %v", err)
		_ = json.NewEncoder(os.Stdout).Encode(output)
		return
	}

	// Verify event type
	if input.EventType != "transcription" && input.EventType != "message.transcribed" {
		// Maybe log that we ignored it? But usually filters handle this.
		// We'll just exit successfully with no events.
		_ = json.NewEncoder(os.Stdout).Encode(output)
		return
	}

	// Extract transcription text
	transcription, ok := input.EventData["transcription"].(string)
	if !ok || transcription == "" {
		output.Events = append(output.Events, logEvent("Skipping empty transcription"))
		_ = json.NewEncoder(os.Stdout).Encode(output)
		return
	}

	// Check engagement
	recentEvents := getRecentEvents()
	start := time.Now()
	engaged, err := checkEngagement(transcription, recentEvents)
	duration := time.Since(start)

	if err != nil {
		output.Events = append(output.Events, createEvent("error_occurred", map[string]interface{}{
			"error": fmt.Sprintf("Engagement check failed: %v", err),
		}))
	} else {
		output.Events = append(output.Events, logEvent(fmt.Sprintf("Engagement check: %v (took %v)", engaged, duration)))

		if engaged {
			// Create child event
			childEvent := createEvent("chat_response_requested", map[string]interface{}{
				"input_text":     transcription,
				"source_event":   input.EventID,
				"source_user":    input.EventData["user_id"], // Assuming these fields exist
				"source_channel": input.EventData["channel_id"],
			})
			output.Events = append(output.Events, childEvent)
		} else {
			// Debug event for no engagement
			debugEvent := createEvent("log_entry", map[string]interface{}{
				"level":   "debug",
				"message": "Dexter decided not to engage",
				"context": "Engagement model returned FALSE",
			})
			output.Events = append(output.Events, debugEvent)
		}
	}

	// Output result
	if err := json.NewEncoder(os.Stdout).Encode(output); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to write output: %v\n", err)
		os.Exit(1)
	}
}
